---
layout: post
title: Autoedit
author: Oswald Berthold
date: 2021-02-17
comments: true
tags: audio tools
---

> autoedit is a Python audio tool that creates automagic edits of
> too-long or too-short audio files, whatever. Randomly, no
> repeat. Generate and test. Good news is, they always sound
> good. How? With big use of small AI. Now available as web app, no
> install required.

### tl;dr autoedit

autoedit is a tool that creates an *edit* from your input file. Edit
means, the input file is broken into chunks and then some chunks are
chosen and arranged in some order to make the output file.

### Quick start

Go to to <https://api.jetpack.cl>

First time round enter your api key. Be in touch to get a key.

On the thw site you will find four red tabs, Drop, Files, Actions,
Tasks. Upload some files via the drop tab, either from your hard disk
or from the internet via a Youtube or similar URL.

Go to the file tab to make sure your files are there.

Go to the Actions tab and select autoedit. In the autoedit
configuration form, add an input file, set the duration to something
small, 30 - 60 seconds. Set the assembly mode to random. Set the
number of segments (numsegs) to something between 20 and 200.

Click start. Wait a bit and download the .wav result and ignore the
other outputs. Don't like it, rerun it, like it. Generate and test.

### What is autoedit?

Autoedit was invented collectively observing a session based
production workflow. Visiting friends in the stu on a regular basis,
we observed that capture (recording the stuff) was being handled, yet
consolidating or even publishing it was not.

A lot of thinking ticks later, we arrived at a workable proposition
consisting of a collection of Python scripts that do the job. A couple
of run-ins with potential users and going through their individual
installation processes told us to create a web app and provide
autoedit in style of Software-as-a-Service (SaaS).

If you're in a hurry, enter <https://api.jetpack.cl>

### Design philosophy

What we are talking about is music cognition and what we use to create
that is a set of libraries from the Music Information Retrieval (MIR)
community [1]. There exists significant amount of music cognition
ability in these libraries.

We set out to create a segmentation of the input file into a set of
different parts. Part in the sense of where you and I would agree that
these do constitute different parts of any given piece of audio
recording. Twenty seconds of the main voice active, 40 seconds of no
bass drum, 12 seconds of a single voice. That kinda stuff, mute on /
off on the desk. In addition we want the large scale segmentation to
be aligned on the beat grid, if the audio has a beat (every audio has
some degree of beat but don't tell anyone, else confusion and cost
rained down on us).

Now there is some realization from that we can put into action:

1/ combine the functionally overlapping feature detectors of different
MIR libraries to obtain an improved result

2/ use philosophy to utilize **onset** type features on two different
time scales

3/ combine two time scales to make beat aligned segment boundary
inferences

4/ use random strategies, they are cheap and always worth it. 

> (Idea can be extended to other domains, that's another post).



### Footnotes

[1] ISMIR Community, TODO insert link

### Comments

{% if page.comments %}
<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = '//x75.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
{% endif %}

